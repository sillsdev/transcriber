import React from 'react';
import path from 'path-browserify';
import {
  BurritoBuilder,
  BurritoLocalizedNames,
} from '../burrito/data/burritoBuilder';
import { useGlobal } from '../context/GlobalContext';
import {
  remoteId,
  useBible,
  pubDataCopyright,
  useOrgDefaults,
  related,
} from '../crud';
import { useOrbitData } from '../hoc/useOrbitData';
import {
  BibleD,
  IState,
  OrganizationBibleD,
  OrganizationD,
  PassageD,
  PlanD,
  ProjectD,
  SectionD,
  UserD,
} from '../model';
import { RecordKeyMap } from '@orbit/records';
import { burritoBooks, burritoProjects } from './BurritoBooks';
import { useDispatch, useSelector } from 'react-redux';
import * as actions from '../store';
import dataPath, { PathType } from '../utils/dataPath';
import { burritoContents, BurritoType } from './BurritoContents';
import { burritoWrapper } from './BurritoWrapper';
import { pad2 } from '../utils/pad2';
import CodeNum from '../assets/code-num.json';
import { useBurritoAudo } from './useBurritoAudo';

const version = require('../../package.json').version;
const productName = require('../../package.json').build.productName;
const ipc = (window as any)?.electron;

export const useCreateBurrito = (teamId: string) => {
  const [memory] = useGlobal('memory');
  const [userId] = useGlobal('user');
  const users = useOrbitData<UserD[]>('user');
  const teams = useOrbitData<OrganizationD[]>('organization');
  const teamBibles = useOrbitData<OrganizationBibleD[]>('organizationbible');
  const bibles = useOrbitData<BibleD[]>('bible');
  const projects = useOrbitData<ProjectD[]>('project');
  const plans = useOrbitData<PlanD[]>('plan');
  const sections = useOrbitData<SectionD[]>('section');
  const passages = useOrbitData<PassageD[]>('passage');
  const { getOrgDefault } = useOrgDefaults();
  const lang = useSelector((state: IState) => state.strings.lang);
  const allBookData = useSelector((state: IState) => state.books.bookData);
  const booksLoaded = useSelector((state: IState) => state.books.loaded);
  const dispatch = useDispatch();
  const fetchBooks = (lang: string) => dispatch(actions.fetchBooks(lang));
  const { getPublishingData } = useBible();
  const [languages, setLanguages] = React.useState<string[]>([]);
  const [bkSecIds, setBkSecIds] = React.useState<[string, string[]][]>([]);
  const burritoAudio = useBurritoAudo(teamId);

  const bookData = (book: string) => allBookData.find((b) => b.code === book);

  React.useEffect(() => {
    if (!booksLoaded) {
      fetchBooks(lang);
    }
    /* eslint-disable-next-line react-hooks/exhaustive-deps */
  }, [lang, booksLoaded]);

  const bible = React.useMemo(() => {
    const teamBibleRec = teamBibles.find(
      (t) => related(t, 'organization') === teamId
    );
    const bibleId = related(teamBibleRec, 'bible');
    return bibles.find((b) => b.id === bibleId);
  }, [teamBibles, bibles, teamId]);

  const books: string[] = React.useMemo(
    () => getOrgDefault(burritoBooks, teamId) || [],
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [teamId]
  );

  const getMetadata = () => {
    const userRec = users.find((user) => user.id === userId);
    const teamRec = teams.find((team) => team.id === teamId);
    const teamRemId =
      remoteId('organization', teamId, memory.keyMap as RecordKeyMap) || teamId;
    const revision = getOrgDefault('burritoRevision', teamId) || '1';
    const localizedNames = {} as BurritoLocalizedNames;
    books.forEach((book) => {
      const bookInfo = bookData(book);
      localizedNames[`book-${book}`.toLowerCase()] = {
        abbr: { [lang]: bookInfo?.abbr || book },
        short: { [lang]: bookInfo?.short || book },
        long: { [lang]: bookInfo?.long || book },
      };
    });
    const copyright = getPublishingData(pubDataCopyright, bible) as string;
    const metaData = new BurritoBuilder()
      .withMeta({
        generator: {
          softwareName: productName,
          softwareVersion: version,
          userName: userRec?.attributes.name || 'Unknown User',
        },
        comments: [
          `Generated by Audio Project Manager from ${
            teamRec?.attributes.name || 'Unknown Team'
          }`,
        ],
      })
      .withIdAuthority('apm', productName)
      .withIdentification({
        primary: {
          apm: {
            [teamRemId]: {
              revision,
              timestamp: new Date().toISOString(),
            },
          },
        },
        name: {
          en:
            bible?.attributes.bibleName ||
            teamRec?.attributes.name ||
            'Unknown Bible',
        },
        description: { en: bible?.attributes.description || '' },
        abbreviation: {
          en: bible?.attributes.bibleId || `${bible?.attributes.iso}New`,
        },
      })
      .withAgency({
        id: `apm::${teamRemId}`,
        roles: ['rightsHolder'],
        name: { en: teamRec?.attributes.name || 'Unknown Team' },
      })
      .withTargetArea('US', 'United States')
      .withLocalizedNames(localizedNames)
      .withCopyright({
        shortStatements: [
          {
            statement: `<p>${copyright}</p>`,
            mimetype: 'text/html',
            lang: 'en',
          },
        ],
      })
      .build();
    metaData.languages = languages.map((l) => {
      const [lang, name] = l.split('|');
      return { tag: lang, name: { en: name } };
    });
    return metaData;
  };

  const getSections = () => {
    const projIds: string[] = getOrgDefault(burritoProjects, teamId) || [];
    const langs: Set<string> = new Set();
    const sectIds: Map<string, string[]> = new Map();
    projects
      .filter((p) => projIds.includes(p.id))
      .forEach((proj) => {
        langs.add(
          `${proj.attributes.language}|${proj.attributes.languageName}`
        );
        const planRec = plans.find((p) => related(p, 'project') === proj.id);
        const sectionRecs = sections.filter(
          (s) => related(s, 'plan') === planRec?.id
        );
        sectionRecs.forEach((section) => {
          const sectBook =
            passages.find(
              (p) =>
                related(p, 'section') === section.id &&
                Boolean(p.attributes.book)
            )?.attributes?.book || '';
          if (sectBook) {
            const curIds = sectIds.get(sectBook) || [];
            sectIds.set(sectBook, [...curIds, section.id]);
          }
        });
      });
    setLanguages(Array.from(langs).sort());
    setBkSecIds(Array.from(sectIds));
  };

  const myName = (name: string, part?: string) =>
    part
      ? path.join(
          PathType.BURRITO,
          bible?.attributes?.bibleId || teamId || '',
          part.toLowerCase(),
          name
        )
      : path.join(
          PathType.BURRITO,
          bible?.attributes?.bibleId || teamId || '',
          name
        );

  const sectionSort = (a: SectionD, b: SectionD) =>
    a.attributes.sequencenum - b.attributes.sequencenum;

  const createPart = async (part: string) => {
    const metaName = await dataPath(
      myName('metadata.json', part),
      PathType.BURRITO
    );
    const preLen = metaName.indexOf('metadata.json');
    await ipc?.createFolder(path.dirname(metaName));
    let metaData = getMetadata();

    await ipc?.write(metaName, JSON.stringify(metaData, null, 2));
    const codeNum = new Map(CodeNum as [string, number][]);
    for (const book of books) {
      // create the book folder
      const bookFolder = pad2(codeNum.get(book) ?? 99) + book;
      const bookPath = await dataPath(
        myName(bookFolder, part),
        PathType.BURRITO
      );
      await ipc?.createFolder(bookPath);
      const bookSectIds = bkSecIds.find((b) => b[0] === book)?.[1] || [];
      const bookSecs = sections
        .filter((s) => bookSectIds.includes(s.id))
        .sort(sectionSort);
      if (part === BurritoType.Audio) {
        burritoAudio({
          metadata: metaData,
          bible: bible as BibleD,
          book,
          bookPath,
          preLen,
          sections: bookSecs,
        });
      }
    }
  };

  return async () => {
    const wrapper = getOrgDefault(burritoWrapper, teamId);
    if (wrapper) {
      const wrapperPath = await dataPath(
        myName('metadata.json'),
        PathType.BURRITO
      );
      await ipc?.createFolder(path.dirname(wrapperPath));
      await ipc?.write(wrapperPath, JSON.stringify(wrapper, null, 2));
    }
    const content: string[] = getOrgDefault(burritoContents, teamId) || [];
    getSections();
    for (const part of content) {
      await createPart(part);
    }
  };
};
